<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=BnIqpcFAcReH0Tw3JLCcnA);ol{margin:0;padding:0}table td,table th{padding:0}.c6{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c5{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Arial";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c8{background-color:#ffffff;font-size:12pt;font-family:"Roboto";color:#202124;font-weight:700}.c9{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c10{text-decoration:none;vertical-align:baseline;font-style:normal}.c2{height:11pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c9 doc-content"><p class="c6 title" id="h.t4i4r5r42mtr"><span class="c4">PID Optimization with Machine Learning</span></p><hr><p class="c1 c2"><span class="c0"></span></p><h1 class="c5" id="h.taxcxbimeu1y"><span class="c7">An Analogy</span></h1><p class="c1"><span class="c0">Imagine you&rsquo;re a baseball pitcher practicing your throws. Like all baseball pitchers, your goal is to throw a baseball at the correct angle so that it hits the catcher&#39;s glove. You throw your first baseball, and it goes too high. You take a mental note of the angle you&rsquo;ve thrown the ball at, and how far the baseball has gone above the catcher. This time, you throw the ball lower. The baseball sails much closer to the pitcher but is too low. Since you&rsquo;re closer to the target, you adjust slightly more upwards, throwing the baseball, and you nail the throw. </span></p><p class="c1 c2"><span class="c0"></span></p><h1 class="c5" id="h.ygg9o5b2irxp"><span class="c7">Gradient Descent</span></h1><p class="c1"><span class="c0">Gradient descent is an optimization algorithm that refines variables like these and is arguably the most fundamental procedure in machine learning. Like the pitcher example, gradient descent takes a guess, calculates whether it&rsquo;s too high or low relative to the target, and refines its guess. Gradient descent can optimize many different variables simultaneously, as long as you can quantify how far off each metric was. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Returning to the pitcher example, imagine if the arc was the path of the ball, and the dot is the target.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 384.50px; height: 277.90px;"><img alt="" src="images/image32.png" style="width: 384.50px; height: 277.90px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><img src="images/image1.png"></p><p class="c3 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Gradient descent first says to find the error in the system. If the target is 4 meters away, we simply subtract the position of the ball (</span><img src="images/image2.png"><span>&nbsp;feet high) from the target (</span><img src="images/image3.png"><span class="c0">&nbsp;feet).</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c3"><img src="images/image4.png"></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">This is where our algorithm diverges from the simple example. The simplest way to adjust the throw is proportional to the negative error. If you throw the ball 1 foot too high, you aim 1 degree lower, if you throw the ball a half foot too low, you aim half a degree up. It doesn&rsquo;t need to be 1-to-1 adjustments, but just some proportionality constant. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>The issue with this is it doesn&rsquo;t work for all cases, imagine if we were trying to adjust the </span><img src="images/image5.png"><span class="c0">&nbsp;constant in our equation or if it was a cubic or square root. The step sizes would be disproportionate to what we&rsquo;re changing, which is why we take the derivative.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">In machine learning, the most common loss function is squared error.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c3"><img src="images/image6.png"></p><p class="c2 c3"><span class="c0"></span></p><p class="c1"><span class="c0">In our case it&rsquo;s easier to quantify the effectiveness of the algorithm using this squared error, since if a robot were to overshoot then undershoot, the error would always stay above 0, a lower squared error would always mean better performance overall.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">To understand how we should affect our system now, we take the derivative of the error with respect to the result.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c3"><img src="images/image7.png"></p><p class="c3 c2"><span class="c0"></span></p><p class="c3"><span class="c0">Now to apply the chain rule:</span></p><p class="c3 c2"><span class="c0"></span></p><p class="c3"><img src="images/image8.png"></p><p class="c3"><img src="images/image9.png"></p><p class="c3 c2"><span class="c0"></span></p><p class="c3"><img src="images/image10.png"></p><p class="c3"><img src="images/image11.png"></p><p class="c3"><img src="images/image12.png"></p><p class="c3 c2"><span class="c0"></span></p><p class="c3"><span class="c0">Therefore:</span></p><p class="c3 c2"><span class="c0"></span></p><p class="c3"><img src="images/image13.png"><span class="c8">&prop; </span><img src="images/image14.png"></p><p class="c1 c2"><span class="c0"></span></p><h1 class="c5" id="h.rlk7up1fgxde"><span class="c7">Applying To VEX:</span></h1><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">When using a PID controller to control turns, the wheels practically start spinning in reverse at some point during the turn to stop as fast as possible. This however is difficult to control, and takes fine tuning of algorithm constants to get right.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">If you were to graph a poorly tuned PID turn, it would look something like this:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 338.67px;"><img alt="" src="images/image34.png" style="width: 624.00px; height: 338.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">The y-axis represents the robots nominal error (error between target and current heading, so an error of 0 would be perfect). The x-axis represents the time since the turn was executed in milliseconds.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Since the robot had a negative nominal error on the interval </span><img src="images/image15.png"><span class="c0">, it means the robot overshot the turn, went past where it was supposed to end before correcting itself.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>The robot is programmed to not end the turn unless the derivative of the nominal error is </span><img src="images/image16.png"><span class="c0">. Meaning the robot&rsquo;s rotation needs to be practically stationary. If we instead applied normal breaking power, the robot would continue to under or over shoot under it&rsquo;s own momentum we allowed the robot to correct itself first.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">When we were brainstorming how we could quantify what a perfectly tuned turn would look like, we settled on looking at the local minimums. In this case, the local minimum is -12 degrees. Meaning, the robot has overshot 12 extra degrees past where it was supposed to stop. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">The opposite can also be true, when the robot stops too early. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 297.33px;"><img alt="" src="images/image31.png" style="width: 624.00px; height: 297.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">This is a less extreme example with better tuning. However, the robot did stop too early and begin reversing it&rsquo;s direction to compensate for it&rsquo;s excess speed. The local minimum here is only 2 degrees, but in early ML training and without proper tuning this can again reach high into the double digits. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">So what do we do?</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Well, the aim is to have no velocity at the angle which we&rsquo;ve set it to turn to. Meaning, we want the local minimum to occer at 0.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">On a graph, this would look like the motion blends seamlessly in with the x-axis. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 472.00px;"><img alt="" src="images/image37.png" style="width: 624.00px; height: 472.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Now to understand how we can tune this:</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c3"><span class="c0">The PID output is defined as</span></p><p class="c3 c2"><span class="c0"></span></p><p class="c3"><img src="images/image17.png"></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Loosely speaking, the </span><img src="images/image18.png"><span>&nbsp;constant controls how fast the robot responds to the error overall. From our pitcher example, we said that if we&rsquo;re 1 foot too high then we should aim 1 degree down. In this system, we multiply however far we were off by </span><img src="images/image19.png"><span>&nbsp;to get how much we should adjust. Likewise, the </span><img src="images/image18.png"><span class="c0">&nbsp;constant here causes the robot to adjust faster while it&rsquo;s far from it&rsquo;s target, and slow down when it&rsquo;s close. It doesn&rsquo;t make sense to change this constant however as changing this would change our movement speed overall, and we only want to control the last part of the term.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>The </span><img src="images/image20.png"><span>&nbsp;gain adjusts the robot in cases of really small errors. In a stand-alone PD controller without an integral part it&rsquo;s difficult to adjust the robot at 1 degree, since our motors are only getting 0.5 volt of power if we had </span><img src="images/image21.png"><span class="c0">, well, to overcome friction you may need more power then that, so the robot may not move. The integral part says is to compound the error over time. When compounding the error, the PID output would grow and grow, until the robot finally overcomes friction and moves. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Finally, the derivative gain responds to how fast the robot is approaching it&rsquo;s target. It&rsquo;s this part of the equation that dampens movement and acts as a brake. So it&rsquo;s this part of the equation we should tune. </span></p><p class="c1 c2"><span class="c0"></span></p><h1 class="c5" id="h.j1wd7fgdbhet"><span class="c7">Ziegler-Nichols Algorithm</span></h1><p class="c1"><span class="c0">There is a well known heuristic to calculate an initial set of PID constants called ziegler-nichols method. This algorithm is a heuristic and differs quite a bit from reality, however, it&rsquo;s a good starting point for the mashine learning algorithms to start off from.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>First and foremost, you find </span><img src="images/image22.png"><span>which is the </span><img src="images/image23.png"><span>&nbsp;value where the robot consistently overshoots to both sides in a wave. This wave at </span><img src="images/image24.png"><span class="c0">&nbsp;is neither growing in strength, nor deteriorating. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Second you measure the wave&rsquo;s oscillating period represented with </span><img src="images/image25.png"><span class="c0">.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>For our robot, </span><img src="images/image26.png"><span>&nbsp;and </span><img src="images/image27.png"><span class="c0">&nbsp;which is 310 milliseconds.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Lastly you find the respective initial values on a look-up table, these values are laboratory tested across many different control systems. For now, we choose to use the Classic PID control type. </span><img src="images/image28.png"><span>&nbsp;are the values we want to calculate.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 280.00px;"><img alt="" src="images/image35.png" style="width: 624.00px; height: 280.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c5" id="h.jgvay9r4f3u3"><span class="c7">Connecting Gradient Decent</span></h1><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Now, we can match this to the pitcher example from before.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>When the robot has overshot it&rsquo;s turn (if the local minimum is less 0) we can increase the </span><img src="images/image23.png"><span>&nbsp;gain by some amount and when the robot underturns we can decrease the </span><img src="images/image23.png"><span class="c0">&nbsp;gain.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">To do this as efficiently as possible and minimizing learning time, we follow the gradient decent algorithm.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">First and foremost, we execute a turn with no derivative gain and monitor for the local minimum.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Local minimums are defined as where the derivative of the motion switches from negative to positive. Here it is in code.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 277.33px;"><img alt="" src="images/image36.png" style="width: 624.00px; height: 277.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">We&rsquo;re only interested in the first local minimum after the robot begins it&rsquo;s turn and none after, hence why we use a conditional to stop checking after the fact. We&rsquo;re also interested in the value at the local minimum, so we store the nominal error. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Finally, we calculate the derivative of the squared error and refine our estimate of </span><img src="images/image29.png"><span class="c0">.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span>Our change to the initial guess shouldn&rsquo;t be equal to the derivative, otherwise the robot&rsquo;s learning would jump all over the place and would hardly refine itself. So we multiply the derivative by the learning rate. Too slow and the robot would hardly learn anything, and too fast and the robot may jump from making overly tuned turns to undertuned and jump back and forth. We found a learning rate of </span><img src="images/image30.png"><span class="c0">&nbsp;works for us.</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 385.33px;"><img alt="" src="images/image39.png" style="width: 624.00px; height: 385.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">And here&rsquo;s a graph of the robot&rsquo;s learning over time of the real error to turn number.</span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 556.00px;"><img alt="" src="images/image33.png" style="width: 624.00px; height: 556.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">As you can see the robot learned to make the perfect turn in less than 10 attempts, rerunning this yielded the same result. I was not able to match this performance by tuning a PID controller by hand. </span></p><p class="c1 c2"><span class="c0"></span></p><p class="c1"><span class="c0">Finally here is a video of the robot learning on hard-wood floors. </span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 300.00px; height: 300.00px;"><img alt="" src="images/image38.png" style="width: 300.00px; height: 300.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>
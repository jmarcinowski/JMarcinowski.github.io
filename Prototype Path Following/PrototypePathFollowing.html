<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c4{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c1{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c9{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c10{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c8{color:inherit;text-decoration:inherit}.c3{height:11pt}.c5{text-indent:36pt}.c11{height:20pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c10 doc-content"><div><p class="c0 c3"><span class="c2"></span></p></div><p class="c4 title" id="h.b0x0z5xo6pb0"><span class="c12">Prototype Path Following</span></p><hr><p class="c0 c3"><span class="c2"></span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0 c3"><span class="c2"></span></p><h1 class="c1" id="h.pr7nwc7qveek"><span class="c6">What is path-following?</span></h1><p class="c0 c3"><span class="c2"></span></p><p class="c0 c5"><span class="c2">Path following is an algorithm that keeps a vehicle traveling along a path. It is helpful to guide the robot to any desired point while maintaining a safe distance from extraneous disks and objects. In the video linked at the end of this notebook entry, a robot managed to avoid obstacles following a path.</span></p><h1 class="c1" id="h.3w6908bu03b7"><span class="c6">What is the goal?</span></h1><p class="c0 c5"><span class="c2">We aim to draw any curved arc on a VEX field and then have a robot follow the curve. While our robot is undergoing a redesign, we first used VEX Codev5 simulations and a dummy bot to develop this algorithm. </span></p><p class="c0 c3 c5"><span class="c2"></span></p><p class="c7 c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 280.20px; height: 294.50px;"><img alt="" src="images/image3.png" style="width: 280.20px; height: 294.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7 c5"><span class="c2">Above is the Path Creator program. Using a computer mouse, we can draw any curve and export it to 300-500 accurate GPS coordinates.</span></p><p class="c7 c3 c5"><span class="c2"></span></p><h1 class="c1 c5 c11" id="h.7fj0ejqizanf"><span class="c6"></span></h1><h1 class="c1" id="h.i8vwfxz59zjc"><span class="c6">Path-Following Overview:</span></h1><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First and foremost, the robot must know its current position and heading. Odometry and GPS are allowed in skills programming, but for simplicity in simulation, we used GPS.</span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Now that the robot knows its current x, y, and angle, it looks ahead of itself forty centimeters, and this point is called the seek point.</span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The seek point is analogous to the point you view when driving a car. Generally speaking, it&rsquo;s not enough information to know the car&#39;s current position on the road. You must look ~15 seconds ahead of the car&#39;s position and drive to that point, which keeps you on track.</span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The path the robot follows is simply an array of points. </span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 409.19px; height: 330.50px;"><img alt="" src="images/image8.png" style="width: 409.19px; height: 330.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The next step for path following is to find the closest path point to the seek point. Just as you turn to the segment of the road point closest to ~15 seconds away, the robot turns to the closest point on the path forty centimeters away. As the robot gets closer to this point, it must target a new one. This perpetual cycle is what gets the robot to follow a path.</span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This step requires the help of another algorithm, the seek algorithm. For the robot to drive to these targeted points, it must have a procedure to drive to a single point. </span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Essentially, the seek algorithm uses the robots </span><img src="images/image1.png"><span class="c2">&nbsp;and the targeted points x and y. With the help of a little trigonometry; the robot can calculate how many degrees left or right it must turn to face the targeted point. From here, the robot simply drives forward, always adjusting its course left and right. We will expand on this later in more detail.</span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finally, we get to the end of the path. The robot knows it&rsquo;s at the end of the path because the targeted point is the last in the path array. The robot simply stops its movement then.</span></p><p class="c0 c3"><span class="c2"></span></p><h1 class="c1" id="h.gvcwjrcufdyk"><span class="c6">Implementation</span></h1><p class="c0 c5"><span class="c2">To work backward, the end goal is to call a path-following function, just like this:</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 423.50px; height: 194.78px;"><img alt="" src="images/image7.png" style="width: 423.50px; height: 194.78px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The PID class controls the robot&#39;s turn reaction to being off-target. The internal workings of PID are beyond the scope of this notebook entry, but in this context, these three values control the turn behavior. With the optimal values, the robot will turn quickly and not overshoot or undershoot. I have already written about finding the optimal PID values for turning in another notebook entry.</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 418.53px; height: 911.50px;"><img alt="" src="images/image4.png" style="width: 418.53px; height: 911.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c2">The FollowPath method.</span></p><p class="c7 c3"><span class="c2"></span></p><p class="c0 c5"><span class="c2">To walk through the code, we set the look-ahead distance to forty centimeters (four hundred millimeters) and repeatedly drove to the target point on the path. If the targeted point wasn&rsquo;t the last, then the robot stopped.</span></p><p class="c0 c3 c5"><span class="c2"></span></p><p class="c0 c5"><span class="c2">Each time the outer loop ran, a nested loop would go through all the path points and find the closest to the seek point. </span></p><p class="c0 c3 c5"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;One notable difference between the theory we discussed and the function is the accumulation of distances. </span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;In the future, I plan to use machine learning to tune the PID controller just as I did for simple turns. The metric to grade the PID controller is the total distance the robot has spent from the line throughout a circuit loop, updating its PID values to minimize path offset.</span></p><p class="c0 c3 c5"><span class="c2"></span></p><p class="c0 c5"><span class="c2">There is a bug in the implementation shared. If all of the path points are further than 9.9 billion millimeters away (9,999 kilometers) from the seek point, then the robot will haphazardly target the first point, which may not be the closest. </span></p><p class="c0 c3 c5"><span class="c2"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 433.50px; height: 260.52px;"><img alt="" src="images/image5.png" style="width: 433.50px; height: 260.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c2">The seek method.</span></p><p class="c7 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The seek method calculates the relative angle to the target between the robot&#39;s current heading and the target. With a PID controller, the robot turns to face the target while driving forward. It&#39;s&rsquo; worth noting that the current_heading is = -GPS.heading() + 90 because VEX sets the y-axis on the GPS 0 heading. While doing trigonometry, the X-axis is always considered 0 degrees, and the y-axis is considered 90. To make life simple, translated vex&rsquo;s GPS units to standard unit circle units so that I will not need to do extraneous calculations in the trigonometry section. </span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The angleToTarget() function largely utilizes the calculateRelativeAngle() function.</span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 525.53px; height: 728.50px;"><img alt="" src="images/image6.png" style="width: 525.53px; height: 728.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lines 22-29 simply handle edge cases, like: &ldquo;what if the robot is on the target point?&rdquo; and &ldquo;what if the robot is on the same x-axis?&rdquo; Doing computations without these checks would to a division of 0 error and cause problems. </span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;From 30 on, we simply compute the arctan of the angle (arctan tells us the angle, in radians of the ratio of the opposite to adjacent triangle legs).</span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It&rsquo;s not enough to simply do arctan. For example, consider if the robot was -100mm in the x direction and -100mm in the y direction from its target (which should be a 225-degree heading). That angle would be different than if the robot was 100mm in the x direction and 100mm in the y direction (traveling at a 45-degree heading), the two angles should be 180 degrees apart.</span></p><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since arctan takes the ratio of the legs, both divide by 1, giving the same angle, 45 degrees. To deal with this, a reference angle must be added depending on the quadrant the robot is in relative to the targeted point. If the robot is in quadrants 1 and 4, 180 could be added. And for quadrants 2 and 3, -180 needs to be added. </span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Since this is the relative angle, it makes sense that if the robot was on the track it should return 0 degrees, and -180 if it makes a full rotation. To handle this, all degrees should be between -180 to 180 and appropriately scaled.</span></p><p class="c0 c3"><span class="c2"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 382.67px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 382.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c2">&nbsp;</span></p><p class="c7"><span class="c2">Note: this is the standard way of converting to a real angle using a reference angle, between 0 and 360 degrees. For our case, we want -180 to 180. </span></p><h1 class="c1" id="h.nnq5vwdp5b03"><span class="c6">Final Result</span></h1><p class="c0 c3"><span class="c2"></span></p><p class="c0"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The path following the prototype was a success. Below is a link to a video of our dummy bot using the path following.</span></p><p class="c0 c3"><span class="c2"></span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 300.00px; height: 300.00px;"><img alt="" src="images/image9.png" style="width: 300.00px; height: 300.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c7"><span class="c9"><a class="c8" href="https://www.google.com/url?q=https://photos.app.goo.gl/3Nkdrrv3MjF9XW9K7&amp;sa=D&amp;source=editors&amp;ust=1694183179164930&amp;usg=AOvVaw3wIt-AguuRtXWQv-hJ1bru">https://photos.app.goo.gl/3Nkdrrv3MjF9XW9K7</a></span></p><p class="c0 c3"><span class="c2"></span></p><p class="c7"><span class="c2">The route that the robot followed</span></p><p class="c7"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 348.64px; height: 367.05px;"><img alt="" src="images/image2.png" style="width: 348.64px; height: 367.05px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>